#!/usr/bin/env bash
set -euo pipefail

# Git-integrated AI helper.
# Modes:
#   explain [backend] [extra instructions]
#   patch   [backend] [extra instructions]

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd)"
AI_WRAPPER="$SCRIPT_DIR/ai"
PATCH_FILE="ai.patch"

if [[ ! -x "$AI_WRAPPER" ]]; then
  echo "Error: unified ai wrapper '$AI_WRAPPER' not found or not executable" >&2
  exit 1
fi

if [[ $# -lt 1 ]]; then
  echo "Usage: $0 {explain|patch} [backend] [extra instructions...]" >&2
  exit 1
fi

MODE="$1"
shift || true

BACKEND="openai"

if [[ $# -gt 0 ]]; then
  case "$1" in
    openai|claude|gemini|hf|huggingface|ollama)
      BACKEND="$1"
      shift || true
      ;;
  esac
fi

USER_TEXT="${*:-}"  # optional extra instructions

if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo "Error: ai-git must be run from inside a Git repository" >&2
  exit 1
fi

GIT_STATUS="$(git status --short --untracked-files=normal || true)"
GIT_DIFF="$(git diff || true)"

# Truncate extremely large diffs to avoid overloading the model
MAX_CHARS=40000
if (( ${#GIT_DIFF} > MAX_CHARS )); then
  GIT_DIFF="${GIT_DIFF:0:MAX_CHARS}\n... [diff truncated]"
fi

PROMPT_MODE_TEXT=""
case "$MODE" in
  explain)
    PROMPT_MODE_TEXT="You are a code assistant. Explain the following Git status and diff. Suggest improvements, refactorings, and tests in plain text only. Do not output any patches or diff markup."
    ;;
  patch)
    PROMPT_MODE_TEXT="You are a code assistant. Given the following Git status and diff plus a user request, produce a unified diff patch ONLY (no commentary). The patch should apply cleanly to the current repository root. Use paths relative to the repo root."
    ;;
  *)
    echo "Usage: $0 {explain|patch} [backend] [extra instructions...]" >&2
    exit 1
    ;;
esac

FULL_PROMPT=$(cat <<EOF
$PROMPT_MODE_TEXT

--- Git status (short) ---
$GIT_STATUS

--- Git diff ---
$GIT_DIFF

--- User request / mode ---
Mode: $MODE
Backend: $BACKEND
Extra instructions: ${USER_TEXT:-<none>}
EOF
)

REPLY="$("$AI_WRAPPER" "$BACKEND" "$FULL_PROMPT")"

if [[ "$MODE" == "patch" ]]; then
  printf '%s
' "$REPLY" >"$PATCH_FILE"
  printf '%s
' "$REPLY"
  echo
  echo "Patch written to: $PATCH_FILE" >&2
  echo "To apply this patch: git apply $PATCH_FILE" >&2
else
  printf '%s
' "$REPLY"
fi
